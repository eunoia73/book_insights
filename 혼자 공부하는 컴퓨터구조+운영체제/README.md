
## 1. 컴퓨터 구조
### 1. 컴퓨터 구조의 큰 그림
#### 1) 컴퓨터가 이해하는 정보
> - **데이터** : 컴퓨터가 이해하는 숫자, 문자, 이미지, 동영상과 같은 정적인 정보
> - **명령어** : 데이터를 움직이고 컴퓨터를 작동시키는 정보

컴퓨터는 명령어를 처리하는 기계이다. <br>
컴퓨터 프로그램은 '명령어들의 모음'이다.

#### 2) 컴퓨터의 4가지 핵심 부품

> 1. **CPU(중앙처리장치)** : 메모리에 저장된 명령어를 읽고 해석하고 실행하는 부품<br>
     - ALU(산술논리연산장치) : 계산기 <br>
     - 레지스터 : CPU 내부의 작은 임시 저장 장치 <br>
     - 제어장치 : 제어신호(전기신호)를 내보내고 명령어를 해석하는 장치


> 2. **메모리(주기억장치)** : 현재 실행되는 프로그램의 명령어와 데이터를 저장하는 부품 <br>
     프로그램이 실행되기 위해서는 메모리에 저장이 되어있어야 함

>3. **보조기억장치** : 전원이 꺼져도 보관될 프로그램을 저장하는 부품

>4. **입출력장치** : 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환하는 장치

#### 3) 메인 보드와 시스템 버스

CPU, 메모리, 보조기억장치, 입출력장치는 모두 `메인보드`에 연결된다.

## 2. 데이터
### 1. 0과 1로 숫자를 표현하는 방법
`비트(bit)` - 0,1로 표현할 수 있는 가장 작은 정보 단위
n비트는 $2^n$가지 정보를 표현할 수 있다.

|단위크기|변환값|
|------|---|
|1byte|8bit|
|1KB|1,000byte|
|1MB|1,000KB|
|1GB|1,000MB|
|1TB|1,000GB|

이진수와 십육진수가 많이 사용되는데, 그 이유는? <br>
→ 이진수와 십육진수 간의 변환이 쉽기 때문이다! <br>
십육진수 한 글자를 4비트의 이진수로 간주하면 된다! <br>
ex. 1A2B → 0001 1010 0010 1011

이진수의 음수 표현은 **2의 보수법**으로 구한다. <br>
(1) 모든 0과 1 뒤집기 (2) 1 더하기 <br>
하지만, 0과  $2^n$형태의 이진수에 2의 보수를 취하면 원하는 음수값을 얻을 수 없는 한계점이 있다.

### 2. 0과 1로 문자를 표현하는 방법
문자 인코딩 : 문자 → 0,1 문자코드 <br>
문자 디코딩 : 0,1 문자코드 → 문자

#### 1) 아스키(ASCII)코드
- 아스키 문자 집합에 0 ~ 127까지의 수가 할당된다.
- 한글 표현 불가

#### 2)EUC-KR
- 하나의 완성된 한글 글자에 코드를 부여
- 모든 한글을 표현할 수는 없음


#### 3) 유니코드
- 여러 나라의 문자들을 광범위하게 표현할 수 있는 통일된 문자 집합
ex. UTF-8



`시스템버스` : 4가지 부품이 서로 정보를 주고받는 통로
- 주소버스, 데이터버스, 제어버스가 있음

## 3. 명령어
### 1. 소스코드와 명령어

- 고급언어 : 사람이 이해하고 작성하기 쉽게 만들어진 언어

- 저급언어 : 컴퓨터가 직접 이해하고 실행할 수 있는 언어

    - 기계어 : 0과 1의 명령어 비트로 이루어진 언어 (ex. 0101 0101)
    - 어셈블리어 : 0과 1로 표현된 기계어를 읽기 편한 형태로 변역한 언어 (ex. push rbp)
    

#### 1) 고급언어를 저급언어로 변환하는 방법

1. 컴파일 방식
- 컴파일 언어 - 컴파일러에 의해 소스코드 전체가 저급 언어로 실행되는 언어
ex. C언어
- 목적 코드 - 컴파일러를 통해 저급 언어로 변환된 코드

<img src="https://velog.velcdn.com/images/eunoia73/post/5474982e-b224-447c-9b87-fd8fc6fe17a6/image.png" width="80%" height="80%">


2. 인터프리트 방식
- 인터프리트 언어 - 인터프리터에 의해 소스 코드가 한 줄씩 실행되는 언어
ex. Python

#### 2) 컴파일 방식과 인터프리트 방식의 차이
컴파일 방식 - 소스 코드 컴파일 중 오류가 발생하면 소스 코드 전체가 실행되지 않는다. <br>
인터프리트 방식 - 소스 코드 인터프리트 중 오류가 발생하면 오류 발생 전까지의 코드는 실행된다. 

**일반적으로 컴파일 언어가 인터프리터 언어보다 빠르다** <br>
→ 컴파일을 통해 나온 목적 코드는 컴퓨터가 실행할 수 있는 저급 언어이지만, 인터프리터 언어는 소스 코드 마지막에 이를 때까지 한 줄씩 저급 언어로 해석하며 실행해야 하기 때문이다. 

### 2. 명령어의 구조
명령어 → 연산 코드 + 오퍼랜드
>  연산 코드 (연산자) - 명령어가 수행할 연산 <br>
데이터 코드, 산술/논리 연산, 제어 흐름 변경, 입출력 제어

>  오퍼랜드 operand (피연산자) - 연산에 사용될 데이터, 연산에 사용할 데이터가 저장된 위치(주소)


#### 1) 주소 지정 방식
1) 즉시 주소 지정 방식 - 연산에 사용될 데이터를 오퍼랜드 필드에 직접 명시

2) 직접 주소 지정 방식 - 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식

3) 간접 주소 지정 방식 - 유효 주소의 주소를 오퍼랜드 필드에 명시. 두 번의 메모리 접근이 필요하므로 상대적으로 느림

4) 레지스터 주소 지정 방식 - 연산에 사용할 데티어를 저장한 레지스터를 오퍼랜드 필드에 직접 명시. 직접 주소 지정 방식과 비슷함

5) 레지스터 간접 주소 지정 방식 - 연산에 사용할 데이터를 메모리에 저장하고, 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법

#### 2) 스택과 큐
스택 stack - 한 쪽 끝이 막혀있는 저장공간 <br>
LIFO(후입선출), PUSH, POP

큐 Queue - 양 쪽이 뚫려있는 저장공간 <br>
FIFO(선입선출)

## 4. CPU의 작동원리
### 1. ALU
➘ **레지스터**를 통해 **피연산자**를 받아들이고, **제어장치**로부터 수행할 연산을 알려주는 **제어신호**를 받아들임 <br>
➚ **연산 결과**와 **플래그**를 내보냄 <br>
결과값은 일시적으로 레지스터에 저장됨 <br>

* 플래그 - 연산 결과에 대한 추가적인 상태 정보 <br>
	CPU가 프로그램을 실행하는 도중 기억해야하는 참고 정보 <br>
	플래그 레지스터에 저장됨 <br>
    부호 플래그, 제로 플래그, 캐리 플래그, 오버플로우 플래그, 인터럽트 플래그, 슈퍼바이저 플래그 등이 있음 <br>
    
### 2. 제어장치
제어 신호를 내보내고 명령어를 해석하는 부품

1) **클럭 신호**를 받아들인다  <br>
클럭 - 컴퓨터의 모든 부품을 움직일 수 있게 하는 시간 단위 <br>
2) 명령어 레지스터로부터 해석해야 할 **명령어**를 받아들인다.  <br>
3) 플래그 레지스터 속 **플래그** 값을 받아들인다. <br>
4) 시스템 버스 중 제어버스로 전달된 **제어 신호**를 받아들인다.  <br>

➚ CPU 내부와 외부로 제어신호를 내보낸다.

### 3. 레지스터
#### 1) 레지스터의 종류
> 1. 프로그램 카운터 - 메모리에서 가져올 명령어의 주소 저장
> 2. 메모리 주소 레지스터 - 메모리의 주소를 저장<br>
	주소 버스로 내보낼 주소값 저장<br>
> 3. 메모리 버퍼 레지스터 - 메모리와 주고받을 값(데이터와 명령어)을 저장<br>
	데이터 버스로 주고받을 값 저장<br>
> 4. 명령어 레지스터 - 메모리에서 읽어들인 명령어(해석할 명령어)를 저장<br>


* 🌊 흐름
1. 프로그램 카운터(PC)<br>
현재 실행할 명령어의 주소를 가지고 있음.<br>
`PC = 100` (100번지의 명령어 실행 예정)<br>

2. 메모리 주소 레지스터(MAR) ← PC
MAR에 PC 값을 복사하여 메모리에서 해당 주소를 읽을 준비를 함.<br>
주소버스로 메모, 제어버스로 제어신호(메모리 읽기) 내보냄<br>
`MAR = 100`<br>

3. 메모리 버퍼 레지스터(MBR) ← 메모리[MAR]<br>
100번지의 메모리에서 명령어(ADD R1, R2)를 읽어 MBR에 저장<br>
데이터 버스로 메모리에 저장된 값이 전달됨<br>
`MBR = ADD R1, R2`

4. 명령어 레지스터(IR) ← MBR<br>
MBR에 있는 명령어를 IR에 저장하여 CPU가 해석할 수 있도록 준비<br>
`IR = ADD R1, R2`<br>

5. PC ← PC + 1<br>
다음 명령어 실행을 위해 PC 증가<br>
`PC = 101`

> 5. 범용 레지스터 - 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터 <br>
> 6. 플래그 레지스터 - 연산 결과 또는 CPU 상태에 대한 부가적인 정보 저장<br>
> 7. 스택 포인터 - 스택의 꼭대기를 가리키는 레지스터<br>
	(스택영역은 메모리 안에 있음)<br>
> 8. 베이스 레지스터 - 프로그램이 실행될 때 특정 기준이 되는 메모리 주소를 저장하는 레지스터<br>

#### 2) 특정 레지스터를 이용한 주소 지정 방식<br>
1. 스택 주소 지정 방식 - 스택과 스택 포인터를 이용한 주소 지정 방식

2. 변위 주소 지정 방식 - 오퍼랜드 필드 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식<br>
	* 상대 주소 지정 방식 - 오퍼랜드와 프로그램 카운터의 값을 더하여 유효주소를 얻는 방식<br>
    주로 조건 분기(조건문)나 루프(loop)에서 사용
    
    * 베이스 레지스터 주소 지정 방식 - 오퍼랜드와 베이스 레지스터의 값을 더하여 유효주소를 얻는 방식<br>
    기준 주소로부터 얼마나 떨어져있는 주소에 접근할 것인지 연산하여 유효 주소를 얻어내는 방식<br>
    주로 운영체제가 프로그램의 시작 주소를 관리할 때 사용

<hr>
[혼자 공부하는 컴퓨터구조 + 운영체제] 책을 읽고 정리한 기록입니다.
