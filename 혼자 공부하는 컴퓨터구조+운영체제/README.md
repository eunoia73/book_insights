
## 1. 컴퓨터 구조
### 1. 컴퓨터 구조의 큰 그림
#### 1) 컴퓨터가 이해하는 정보
> - **데이터** : 컴퓨터가 이해하는 숫자, 문자, 이미지, 동영상과 같은 정적인 정보
> - **명령어** : 데이터를 움직이고 컴퓨터를 작동시키는 정보

컴퓨터는 명령어를 처리하는 기계이다. <br>
컴퓨터 프로그램은 '명령어들의 모음'이다.

#### 2) 컴퓨터의 4가지 핵심 부품

> 1. **CPU(중앙처리장치)** : 메모리에 저장된 명령어를 읽고 해석하고 실행하는 부품<br>
     - ALU(산술논리연산장치) : 계산기 <br>
     - 레지스터 : CPU 내부의 작은 임시 저장 장치 <br>
     - 제어장치 : 제어신호(전기신호)를 내보내고 명령어를 해석하는 장치


> 2. **메모리(주기억장치)** : 현재 실행되는 프로그램의 명령어와 데이터를 저장하는 부품 <br>
     프로그램이 실행되기 위해서는 메모리에 저장이 되어있어야 함

>3. **보조기억장치** : 전원이 꺼져도 보관될 프로그램을 저장하는 부품

>4. **입출력장치** : 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환하는 장치

#### 3) 메인 보드와 시스템 버스

CPU, 메모리, 보조기억장치, 입출력장치는 모두 `메인보드`에 연결된다.

## 2. 데이터
### 1. 0과 1로 숫자를 표현하는 방법
`비트(bit)` - 0,1로 표현할 수 있는 가장 작은 정보 단위
n비트는 $2^n$가지 정보를 표현할 수 있다.

|단위크기|변환값|
|------|---|
|1byte|8bit|
|1KB|1,000byte|
|1MB|1,000KB|
|1GB|1,000MB|
|1TB|1,000GB|

이진수와 십육진수가 많이 사용되는데, 그 이유는? <br>
→ 이진수와 십육진수 간의 변환이 쉽기 때문이다! <br>
십육진수 한 글자를 4비트의 이진수로 간주하면 된다! <br>
ex. 1A2B → 0001 1010 0010 1011

이진수의 음수 표현은 **2의 보수법**으로 구한다. <br>
(1) 모든 0과 1 뒤집기 (2) 1 더하기 <br>
하지만, 0과  $2^n$형태의 이진수에 2의 보수를 취하면 원하는 음수값을 얻을 수 없는 한계점이 있다.

### 2. 0과 1로 문자를 표현하는 방법
문자 인코딩 : 문자 → 0,1 문자코드 <br>
문자 디코딩 : 0,1 문자코드 → 문자

#### 1) 아스키(ASCII)코드
- 아스키 문자 집합에 0 ~ 127까지의 수가 할당된다.
- 한글 표현 불가

#### 2)EUC-KR
- 하나의 완성된 한글 글자에 코드를 부여
- 모든 한글을 표현할 수는 없음


#### 3) 유니코드
- 여러 나라의 문자들을 광범위하게 표현할 수 있는 통일된 문자 집합
ex. UTF-8



`시스템버스` : 4가지 부품이 서로 정보를 주고받는 통로
- 주소버스, 데이터버스, 제어버스가 있음

## 3. 명령어
### 1. 소스코드와 명령어

- 고급언어 : 사람이 이해하고 작성하기 쉽게 만들어진 언어

- 저급언어 : 컴퓨터가 직접 이해하고 실행할 수 있는 언어

    - 기계어 : 0과 1의 명령어 비트로 이루어진 언어 (ex. 0101 0101)
    - 어셈블리어 : 0과 1로 표현된 기계어를 읽기 편한 형태로 변역한 언어 (ex. push rbp)
    

#### 1) 고급언어를 저급언어로 변환하는 방법

1. 컴파일 방식
- 컴파일 언어 - 컴파일러에 의해 소스코드 전체가 저급 언어로 실행되는 언어
ex. C언어
- 목적 코드 - 컴파일러를 통해 저급 언어로 변환된 코드

<img src="https://velog.velcdn.com/images/eunoia73/post/5474982e-b224-447c-9b87-fd8fc6fe17a6/image.png" width="80%" height="80%">


2. 인터프리트 방식
- 인터프리트 언어 - 인터프리터에 의해 소스 코드가 한 줄씩 실행되는 언어
ex. Python

#### 2) 컴파일 방식과 인터프리트 방식의 차이
컴파일 방식 - 소스 코드 컴파일 중 오류가 발생하면 소스 코드 전체가 실행되지 않는다. <br>
인터프리트 방식 - 소스 코드 인터프리트 중 오류가 발생하면 오류 발생 전까지의 코드는 실행된다. 

**일반적으로 컴파일 언어가 인터프리터 언어보다 빠르다** <br>
→ 컴파일을 통해 나온 목적 코드는 컴퓨터가 실행할 수 있는 저급 언어이지만, 인터프리터 언어는 소스 코드 마지막에 이를 때까지 한 줄씩 저급 언어로 해석하며 실행해야 하기 때문이다. 

### 2. 명령어의 구조
명령어 → 연산 코드 + 오퍼랜드
>  연산 코드 (연산자) - 명령어가 수행할 연산 <br>
데이터 코드, 산술/논리 연산, 제어 흐름 변경, 입출력 제어

>  오퍼랜드 operand (피연산자) - 연산에 사용될 데이터, 연산에 사용할 데이터가 저장된 위치(주소)


#### 1) 주소 지정 방식
1) 즉시 주소 지정 방식 - 연산에 사용될 데이터를 오퍼랜드 필드에 직접 명시

2) 직접 주소 지정 방식 - 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식

3) 간접 주소 지정 방식 - 유효 주소의 주소를 오퍼랜드 필드에 명시. 두 번의 메모리 접근이 필요하므로 상대적으로 느림

4) 레지스터 주소 지정 방식 - 연산에 사용할 데티어를 저장한 레지스터를 오퍼랜드 필드에 직접 명시. 직접 주소 지정 방식과 비슷함

5) 레지스터 간접 주소 지정 방식 - 연산에 사용할 데이터를 메모리에 저장하고, 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법

#### 2) 스택과 큐
스택 stack - 한 쪽 끝이 막혀있는 저장공간 <br>
LIFO(후입선출), PUSH, POP

큐 Queue - 양 쪽이 뚫려있는 저장공간 <br>
FIFO(선입선출)

## 4. CPU의 작동원리
### 1. ALU
➘ **레지스터**를 통해 **피연산자**를 받아들이고, **제어장치**로부터 수행할 연산을 알려주는 **제어신호**를 받아들임 <br>
➚ **연산 결과**와 **플래그**를 내보냄 <br>
결과값은 일시적으로 레지스터에 저장됨 <br>

* 플래그 - 연산 결과에 대한 추가적인 상태 정보 <br>
	CPU가 프로그램을 실행하는 도중 기억해야하는 참고 정보 <br>
	플래그 레지스터에 저장됨 <br>
    부호 플래그, 제로 플래그, 캐리 플래그, 오버플로우 플래그, 인터럽트 플래그, 슈퍼바이저 플래그 등이 있음 <br>
    
### 2. 제어장치
제어 신호를 내보내고 명령어를 해석하는 부품

1) **클럭 신호**를 받아들인다  <br>
클럭 - 컴퓨터의 모든 부품을 움직일 수 있게 하는 시간 단위 <br>
2) 명령어 레지스터로부터 해석해야 할 **명령어**를 받아들인다.  <br>
3) 플래그 레지스터 속 **플래그** 값을 받아들인다. <br>
4) 시스템 버스 중 제어버스로 전달된 **제어 신호**를 받아들인다.  <br>

➚ CPU 내부와 외부로 제어신호를 내보낸다.

### 3. 레지스터
#### 1) 레지스터의 종류
> 1. 프로그램 카운터 - 메모리에서 가져올 명령어의 주소 저장
> 2. 메모리 주소 레지스터 - 메모리의 주소를 저장<br>
	주소 버스로 내보낼 주소값 저장<br>
> 3. 메모리 버퍼 레지스터 - 메모리와 주고받을 값(데이터와 명령어)을 저장<br>
	데이터 버스로 주고받을 값 저장<br>
> 4. 명령어 레지스터 - 메모리에서 읽어들인 명령어(해석할 명령어)를 저장<br>
 

* 🌊 흐름
1. 프로그램 카운터(PC)<br>
현재 실행할 명령어의 주소를 가지고 있음.<br>
`PC = 100` (100번지의 명령어 실행 예정)<br>

2. 메모리 주소 레지스터(MAR) ← PC
MAR에 PC 값을 복사하여 메모리에서 해당 주소를 읽을 준비를 함.<br>
주소버스로 메모, 제어버스로 제어신호(메모리 읽기) 내보냄<br>
`MAR = 100`<br>

3. 메모리 버퍼 레지스터(MBR) ← 메모리[MAR]<br>
100번지의 메모리에서 명령어(ADD R1, R2)를 읽어 MBR에 저장<br>
데이터 버스로 메모리에 저장된 값이 전달됨<br>
`MBR = ADD R1, R2`

4. 명령어 레지스터(IR) ← MBR<br>
MBR에 있는 명령어를 IR에 저장하여 CPU가 해석할 수 있도록 준비<br>
`IR = ADD R1, R2`<br>

5. PC ← PC + 1<br>
다음 명령어 실행을 위해 PC 증가<br>
`PC = 101`

> 5. 범용 레지스터 - 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터 <br>
> 6. 플래그 레지스터 - 연산 결과 또는 CPU 상태에 대한 부가적인 정보 저장<br>
> 7. 스택 포인터 - 스택의 꼭대기를 가리키는 레지스터<br>
	(스택영역은 메모리 안에 있음)<br>
> 8. 베이스 레지스터 - 프로그램이 실행될 때 특정 기준이 되는 메모리 주소를 저장하는 레지스터<br>

#### 2) 특정 레지스터를 이용한 주소 지정 방식<br>
1. 스택 주소 지정 방식 - 스택과 스택 포인터를 이용한 주소 지정 방식

2. 변위 주소 지정 방식 - 오퍼랜드 필드 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식<br>
	* 상대 주소 지정 방식 - 오퍼랜드와 프로그램 카운터의 값을 더하여 유효주소를 얻는 방식<br>
    주로 조건 분기(조건문)나 루프(loop)에서 사용
    
    * 베이스 레지스터 주소 지정 방식 - 오퍼랜드와 베이스 레지스터의 값을 더하여 유효주소를 얻는 방식<br>
    기준 주소로부터 얼마나 떨어져있는 주소에 접근할 것인지 연산하여 유효 주소를 얻어내는 방식<br>
    주로 운영체제가 프로그램의 시작 주소를 관리할 때 사용


### 4. 명령어 사이클과 인터럽트
명령어 사이클 - 하나의 명령어를 처리하는 정형화된 흐름 <br>
	인출, 실행, 간접, 인터럽트 사이클이 있음 <br>
인터럽트 - 흐름이 끊어지는 상황, CPU의 작업을 방해하는 신호

1) 동기 인터럽트(예외) - CPU에 의해 발생
- 폴트fault - 예외를 처리한 직후 예외가 발생한 명령어부터 실행을 재개하는 예외 
- 트랩trap - 예외를 처리한 직후 예외가 발생한 명령어의 다음 명령어부터 실행을 재개하는 예외. 디버깅시 사용
- 중단abort - CPU가 실행 중인 프로그램을 강제로 중단시킬 수밖에 없는 심각한 오류를 발견했을 떄 발생하는 예외

2) 비동기 인터럽트(하드웨어 인터럽트) - 입출력 장치에 의해 발생
- 입출력장치가 CPU에 인터럽트 요청 신호를 보냄
- 인터럽트 플래그를 통해 받아들일 수 있는지 확인
- CPU는 스택에 지금 실행하고 있던 작업을 백업
- 인터럽트 벡터(인터럽트 서비스 루틴의 시작 주소 등 식별 정보)를 참조하여 인터럽트 서비스 루틴(인터럽트 처리 프로그램)을 실행

## 5. CPU 성능 향상 기법
### 1. 빠른 CPU를 위한 설계 기법

1) `클럭` - 클럭 속도가 높은 CPU는 빠르게 동작하지만, 무작정 높이면 발열 문제가 심하다

2) `코어` - CPU 내에서 명령어를 실행하는 부품. 코어마다 처리할 명령어를 얼마나 적절하게 분배하느냐에 따라서 연산속도가 달라진다.
- 멀티코어 프로세서 - 명령어를 실행할 수 있는 하드웨어 부품이 CPU안에 두 개 이상 있는 CPU

3) `스레드` - 실행 흐름의 단위. 명령어를 실행하는 단위 <br>
하드웨어적 스레드 - 하나의 코어가 동시에 처리하는 명령어 단위 <br>
멀티 스레드 프로세서 - 여러 개의 하드웨어적 스레드를 지원하는 CPU <br>
소프트웨어적 스레드 - 하나의 프로그램에서 독립적으로 실행되는 단위

### 2. 명령어 병렬 처리 기법
#### 1. 명령어 파이프라이닝 
[명령어 인출 → 해석 → 실행 → 결과 저장] 같은 단계가 겹치치만 않으면 동시에 실행할 수 있는데, 이렇게 동시에 여러 명령어를 겹쳐서 실행하는 기법

** 파이프라인 위험
1) 데이터 위험 - 데이터 의존적인 두 명령어를 동시에 실행하려고 할 때 파이프라인이 작동하지 않는 것 <br>
2) 제어 위험 - 분기 등으로 인한 프로그램 카운터의 갑작스러운 변화에 의해 발생 <br>
3) 구조적 위험 - 명령어를 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등 CPU 부품을 사용하려고 할 때 발생 <br>

#### 2. 슈퍼스칼라
CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조 <br>
공장 생산 라인 여러 개를 두는 것과 같음

#### 3. 비순차적 명령어 처리
의존성이 없는, 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 명령어 파이프라인이 멈추는 것을 방지하는 기법


### 3. CISC와 RISC
ISA(Instruction Set Architecture) - 명령어 집합 구조. CPU의 언어이자 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속

#### 1. CISC (Complex Instruction Set Computer)
- ex. x86, x86-64
- 가변 길이 명령어 사용
- 상대적으로 적은 수의 명령어로 프로그램 실행가능 → 메모리 절약 가능
- 명령어의 규격화가 어려워 파이프라이닝이 어려움

#### 2. RISC (Reduced Instruction Set Computer)
- 단순하고 적은 수의 고정 길이 명령어 사용
- 자주 쓰이는 기본적인 명령어를 작고 빠르게 만듦
- 1클럭 내외로 명령어 수행 → 파이프라이닝 쉬움

## 6. 메모리와 캐시 메모리
### 1. RAM의 특징과 종류
RAM - 실행할 프로그램의 명령어와 데이터가 저장되는 휘발성 저장 장치
cf) 보조기억장치 - 저장될 내용이 유지되는 비휘발성 저장 장치

1) DRAM(Dynamic RAM) - 시간이 지나면 저장된 데이터가 점차 사라지는 RAM. 데이터의 소멸을 막기 위해 일정 주리고 데이터를 재활성화해야 함
소비전력이 비교적 낮고 저렴, 집접도가 높음 → 대용량 설계 용이

2) SRAM(Static RAM) - 시간이 지나도 저장된 데이터가 사라지지 않음(비휘발성이 아니라 전원 공급이 끊기면 저장된 내용이 날라감) DRAM보다 일반적으로 속도 빠름
소비전력 크고 비쌈, 집적도 낮음

3) SDRAM(Synchronous Dynamic RAM) - 클럭에 맞춰 동작하며 클럭마다 CPU와 정보를 주고받을 수 있는 DRAM

4) DDR SDRAM(Double Data Rate SDRAM) - 대역폭을 넓혀 속도를 빠르게 만든 SDRAM <br>
SDR SDRAM(Single Data Rate SDRAM - 한 클럭당 하나씩 데이터를 주고받을 수 있는 SDRAM)보다 대역폭이 2배 넓음
** 대역폭 - 데이터를 주고받는 길의 너비

### 2. 메모리의 주소 공간 
물리 주소 - 메모리 하드웨어가 사용하는 주소. 정보가 실제고 저장된 하드웨어 상의 주소 <br>
논리 주소 - CPU와 실행 중인 프로그램이 사용하는 주소. 실행 중인 프로그램 각각에게 부여된 0번지부터 시작되는 주소 <br>
** CPU와 메모리가 상호작용하려면 논리 주소와 물리 주소 간 변환이 이루어져야함 <br>
MMU(메모리 관리 장치) - 논리 주소와 물리 주소 간의 변환을 하는 하드웨어. CPU와 주소 버스 사이에 위치 <br> CPU가 발생시킨 논리 주소에 베이스 레지스터 값을 더하여 논리 주소를 물리 주소로 변환

베이스 레지스터 - 프로그램의 첫 물리주소 <br>
한계 레지스터 - 논리 주소의 최대 크기 저장 <br> 
논리 주소 - 프로그램의 시작점으로부터 떨어진 거리 <br>
프로그램의 물리 주소 - 베이스 레지스터 + 논리 주소 <br>
> 베이스 레지스터 값 <= 프로그램 물리 주소 < (베이스 레지스터 값 + 한계 레지스터 값) <br>
CPU가 한계 레지스터 보다 높은 논리주소에 접근하려고 하면 인터럽트(트랩)를 발생시켜 실행을 중단함

### 3. 캐시 메모리
#### 1) 저장 장치 계층 구조
: CPU에 얼마나 가까운가를 기준으로 계층적으로 나타낸 것 <br>
* CPU와 가까운 저장 장치는 빠르고, 멀리 있는 저장 장치는 느리다
* 속도가 빠른 저장 장치는 저장 용량이 작고, 가격이 비싸다

> 레지스터 / 캐시 메모리 / 메모리 / 보조기억장치

#### 2) 캐시 메모리 용어
캐시 메모리 - CPU와 메모리 사이에 위치하고, 레지스터보다 용량이 크고 메모리보다 빠른 SRAM기반의 저장 장치 <br>

캐시 히트 - 자주 사용될 것으로 예측한 데이터가 실제로 맞아서 캐시 메모리 내 데이터가 CPU에서 활용될 경우 <br>
케시 미스 - 자주 사용될 것으로 예측하여 캐시 메모리에 저장했지만 예측이 틀려 필요한 데이터를 직접 가져와야 하는 경우 <br>
캐시 적중률 = 캐시 히트 횟수 / (캐시 히트 횟수 + 캐시 미스 횟수)

**참조 지역성의 원리**
* 시간 지역성 - CPU는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향이 있다
* 공간 지역성 - CPU는 접근한 메모리 공간 근처를 접근하려는 경향이 있다

## 7. 보조기억장치
### 1. 다양한 보조기억장치
#### 1) 하드 디스크
자기적인 방식으로 데이터를 저장하는 보조기억장치
* 플래터 - 데이터가 저장되는 곳. 자기 물질로 덮여있어 N, S극을 저장
트랙과 섹터로 나뉘고 여러 플래터의 동일한 트랙이 모여 실린더를 이룸
* 스핀들 - 플래터를 회전시킴
* 헤드 - 플래터를 대상으로 데이터를 읽고 쓰는 구성 요소
* 디스크 암 - 헤드를 원하는 위치로 이동시킴

#### 2) 플래시 메모리
전기적으로 데이터를 읽고 쓸 수 있는 반도체 기반의 저장 장치
* 셀 - 플래시 메모리에서 데이터를 저장하는 가장 작은 단위
한 셀에 몇 비트를 저장할 수 있느냐에 따라 SLC, MLC, TLC로 나뉨
* Free 상태 - 어떤 데이터도 없는 상태
* Valid 상태 - 이미 유효한 데이터를 저장하고 있는 상태
* Invalid 상태 - 쓰레기값이라 부르는 유효하지 않은 데이터를 저장하는 상태
* 가비지 컬렉션 - 데이터 덮어쓰기가 불가능하여, 유효한 페이지만 새로운 블록으로 복사한 후 기존 블록을 삭제하여 공간을 정리하는 기능

### 2. RAID의 정의와 종류
RAID - 하드 디스크와 SSD를 사용하는 기술.  <br> 데이터의 안정성, 높은 성능을 위해 여러 개의 물리적 보조기억장치를 마치 하나의 논리적 보조기억장치처럼 사용하는 기술
1) RAID 0 - 여러 개의 보조기억장치에 데이터를 단순히 병렬로 분산하여 저장하는 방식
2) RAID 1 - 완전한 복사본을 만듦
3) RAID 4 - 패리티를 저장한 장치를 따로 두는 방식
패리티 비트 - 오류를 검출하고 복구하기 위한 정보
4) RAID 5 - 패리티를 분산하여 저장하는 방식(병목현상 해소)
5) RAID 6 - 서로 다른 두 개의 패리티를 두는 방식

## 8. 입출력장치
### 1. 장치 컨트롤러와 장치 드라이버
#### 1) 장치 컨트롤러 (하드웨어)
> * CPU와 입출력장치 간의 통신 중개
> * 오류 검출
> * 데이터 버퍼링 (버퍼에 데이터를 조금씩 모았다가 한꺼번에 재보내거나 데이터를 한 번에 많이 받아 조금씩 내보내는 방법)

장치 컨트롤러의 내부에는 `데이터 레지스터`, `상태 레지스터`, `제어 레지스터` 등이 있다.

** 장치 컨드롤러가 필요한 이유
입출력장치는 종류가 매우 많아서 정보를 주고받는 방식을 규격화하기 어려움  <br> 
일반적으로 CPU와 메모리의 데이터 전송률은 높지만 입출력장치의 데이터 전송률(얼마나 빨리 교환할 수 있는가)은 낮음

#### 2) 장치 드라이버
장치 컨트롤러의 동작을 감지하고 제어함으로써 장치 컨트롤러가 컴퓨터 내부와 정보를 주고받을 수 있게 하는 프로그램

### 2. 다양한 입출력 방법
#### 1) 프로그램 입출력
프로그램 속 명령어로 입출력장치를 제어하는 방법
* 메모리 맵 입출력 - 메모리에 접근하기 위한 주소 공간과 입출력장치에 접근하기 위한 주소 공간을 하나의 주소 공간으로 간주하는 방법
* 고립형 입출력 - 메모리를 위한 주소 공간과 입출력장치를 위한 주소 공간을 분리하는 방법. 입출력 전용 명령어 사용.

#### 2) 인터럽트 기반 입출력
장치 컨트롤러에 의해 발생하는 하드웨어 인터럽트를 기반으로 하는 입출력
* 장치 컨트롤러가 입출력 작업을 끝내고 CPU에게 인터럽트 요청 신호를 보내면 CPU는 하던 일을 백업하고 인터럽트 서비스 루틴을 실행함
* CPU는 인터럽트 간 우선순위를 고려하여 우선순위가 높은 인터럽트 순으로 여러 인터럽트를 처리할 수 있음

* NMI(Non-Maskable Interrupt) - 인터럽트 비트를 활성화해도 무시할 수 없는 인터럽트. 발생시, CPU는 우선순위가 높은 인터럽트부터 처리
* 프로그래머블 인터럽트 컨트롤러(PIC) - 여러 장치 컨트롤러에 연결되어 장치 컨트롤러에서 보낸 하드웨어 인터럽트 요청의 우선순위를 판별한 후, CPU에 처리해야할 하드웨어 인터럽트를 알려주는 장치

#### 3) DMA 입출력
입출력장치와 메모리가 CPU를 거치지 않고도 상호작용할 수 있는 입출력 방식. 직접 메모리에 접근할 수 있는 입출력 기능. <br> 시스템 버스에 연결된 DMA 컨트롤러라는 하드웨어가 필요하다.
* 입출력 버스 - 입출력장치와 컴퓨터 내부를 연결 짓는 통로. 입출력 작업 과정에서 시스템 버스 사용 횟수를 줄여줌

## 9. 운영체제 시작하기
### 1. 운영체제란
`운영체제` - 실행할 프로그램에 필요한 자원을 할당하고, 프로그램이 올바르게 실행되도록 돕는 프로그램 <br>
실행할 프로그램을 메모리에 적재하고 실행 되지 않는 프로그램을 메모리에서 삭제하며 지속적으로 메모리 자원을 관리함

> 운영체제의 핵심 서비스
> * 프로세스 관리
> * 자원 접근 및 할당
> * 파일 시스템 관리

`커널 영역` - 운영체제가 적재되는 영역(메모리 공간) <br>
`사용자 영역` - 사용자가 이용하는 응용 프로그램이 적재되는 영역 

### 2. 운영체제의 큰 그림

`커널` - 운영체제의 핵심 서비스를 담당하는 부분. 자원에 접근하고 조작하는 기능, 프로그램이 올바르고 안전하게 실행되게 하는 기능을 함.

사용자 인터페이스(UI: User Interface) - 운영체계가 제공하는 서비스 중 커널에 포함되지 않는 서비스 <br>
* 그래픽 유저 인터페이스(GUI: Graphical User Interface) - 그래픽 기반으로 컴퓨터와 상호작용할 수 있는 인터페이스
* 커맨드 라인 인터페이스(CLI: Command Line Interface) - 명령어 기반으로 컴퓨터와 상호작용할 수 있는 인터페이스

#### 이중모드와 시스템 호출
운영체제는 사용자가 실행하는 응용 프로그램이 하드웨어 자원에 직접 접근하는 것을 방지하여 자원을 보호함 <br>
`이중 모드` - CPU가 명령어를 실행하는 모드를 '사용자 모드', '커널 모드'로 구분하는 방식 
* 사용자 모드 - 커널 영역의 코드를 실행할 수 없는 모드
* 커널 모드 - 운영체제 서비스를 제공받을 수 있는 실행 모드. 커널 영역의 코드를 실행할 수 있는 모드
<br>
`시스템 콜` - 운영체제 서비스를 제공받기 위해 커널 모드로 전환하는 방법. 소프트웨어 인터럽트 

## 10. 프로세스와 스레드
### 1. 프로세스 개요
`프로세스` - 실행 중인 프로그램. 보조기억장치에 저장된 프로그램을 메모리에 적재하고 실행하는 순간 프로그램은 프로세스가 됨
* 포그라운드 프로세스 - 사용자가 보는 앞에서 실행되는 프로세스
* 백그라운드 프로세스 - 사용자가 보지 못하는 뒤편에서 실행되는 프로세스
* 데몬(서비스) - 사용자와 상호작용하지 않고 정해진 일만 수행하는 백그라운드 프로세스

`프로세스 제어 블록(PCB)` - 프로세스와 관련된 정보를 저장하는 자료 구조 <br> 운영체제는 프로세스의 실행 순서를 관리하고 프로세스에 CPU를 비롯한 자원을 배분하는데, 이 때 PCB를 이용한다. <br>
프로세스ID(PID), 레지스터 값, 프로세스 상태, CPU 스케줄링 정보, 메모리 관리 정보, 사용한 파일과 입출력장치 목록 등을 가지고 있음

`문맥 교환` - 프로세스 간 실행을 전환하는 것 <br>기존 프로세스의 문맥을 PCB에 백업하고, 새로운 프로세스를 실행하기 위해 문맥을 PCB에서 복구하여 새로운 프로세스를 실행하는 것 <br>
`문맥` - 하나의 프로세스 수행을 재개하기 이해 기억해야 할 정보

#### 프로세스의 메모리 영역
> 정적 할당 영역
>  * 코드 영역 - 실행할 수 있는 코드, 기계어로 이뤄진 명령어 저장. 읽기 전용
> * 데이터 영역 - 프로그램이 실행되는 동안 유지할 데이터 저장(전역변수)

> 동적 할당 영역
> * 힙 영역 - 프로그래머가 직접 할당할 수 있는 저장공간(반환하지 않으면 메모리 누수 발생 가능성 있음)
> * 스택 영역 - 데이터를 일시적으로 저장하는 공간(매개변수, 지역변수)

### 2. 프로세스 상태와 계층 구조
1) `생성 상태` new - 프로세스를 생성 중인 상태
2) `준비 상태` ready - CPU를 할당받아 실행 가능한 상태이지만, 차례가 되지 않아 기다리고 있는 상태 (`디스패치` - 준비 상태에서 실행 상태로 전환되는 것)
3) `실행 상태` running - CPU를 할당받아 실행 중인 상태 <br> (할당된 시간을 모두 사용하면 `준비상태`가 됨. 실행 도중 입출력 장치의 작업을 기다린다면 `대기 상태`가 됨)
4) `대기 상태` blocked - 입출력장치의 작업을 기다리는 상태
5) `종료 상태` terminated - 프로세스가 종료된 상태

#### * 프로세스 생성 기법
`fork` - 자신의 프로세스의 복사본을 자식 프로세스로 생성하는 시스템 호출 <br>
`exec` - 자신의 메모리 공간을 새로운 프로그램으로 덮어쓰는 시스템 호출

### 3. 스레드
프로세스를 구성하는 실행의 흐름 단위 <br>
프로세스의 스레드들은 실행에 필요한 최소한의 정보(프로그램 카운터, 스택, 레지스터)는 개별적으로 유지한 채, 프로세스의 자원을 공유하며 실행됨

## 11. CPU 스케줄링
### 1. CPU 스케줄링
운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것 <br>
`입출력 집중 프로세스`는 우선순위가 높은 프로세스이다. <br>
→ 입출력을 위한 대기 상태에 더 많이 머무르게 되기 때문에 빨리 실행시키고 나서 CPU 집중 프로세스를 실행시키는게 효율적이다.

#### 스케줄링 큐
`준비 큐` - CPU를 이용하고 싶은 프로세스들이 서는 줄 <br>
`대기 큐` - 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄

`선점형 스케줄링` - 다른 프로세스가 이용 중인 자원을 빼앗을 수 있음<br> 더 급한 프로세스가 끼어들어 사용할 수 있지만, 문맥 교환이 많이 일어남 <br>
`비선점형 스케줄링` - 다른 프로세스가 이용 중인 자원을 빼앗을 수 없음 <br> 모든 프로세스가 골고루 자원을 사용할 수 없음

### 2. CPU 스케줄링 알고리즘
1) FCFS(First In First Out)스케줄링 <br> 준비 큐에 삽입된 순서대로 프로세스를 처리하는 비선점형 스케줄링 방식. 프로세스가 기다리는 시간이 길어질 수 있음 <br>

2) SJF(Shortest Job First Scheduling)스케줄링 <br> CPU이용 시간의 길이가 가장 짧은 프로세스부터 실행하는 방식 <br>

3) 라운드 로빈 스케줄링 <br> FCFS + 타임 슬라이스 <br> 삽입된 순서대로 CPU를 정해진 시간만큼 이용하고, 완료되지 않은 프로세스는 큐의 마지막에 삽입됨 <br> 타임 슬라이스 - 각 프로세스가 CPU를 사용할 수 있는 정해진 시간 <br>

4) SRT(Shortest Remaining Time)스케줄링 <br> SJF + 라운드 로빈 알고리즘 <br>
정해진 타임 슬라이스만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스로 남아있는 작업시간이 가장 적은 프로세스가 선택됨 <br>

5) 우선순위 스케줄링 <br> 프로세스에 우선순위를 부여하고 가장 높은 우선순위부터 실행 <br> `기아현상` - 우선순위가 낮은 프로세스가 실행이 계속해서 밀리는 형태 <br> `에이징` - 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식 <br>

6) 다단계 큐 스케줄링 <br> 우선순위별로 준비 큐를 여러 개 사용하는 스케줄링 방법 <br>

7) 다단계 피드백 큐 스케줄링 <br> 프로세스들이 준비 큐 사이를 이동할 수 있음 <br> 일반적인 CPU 스케줄링 알고리즘



<hr>
[혼자 공부하는 컴퓨터구조 + 운영체제] 책을 읽고 정리한 기록입니다.
